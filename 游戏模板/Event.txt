Event

事件

是逻辑控制模块中的底层单位，通常实现某种功能
如：控制 A 物体绕 B 物体旋转等。

同时，事件要支持基础的扩展功能，即一个事件要可以由其他事件组成
这使得我们可以在一个事件的初始化中写
add(下雨)
add(打雷)
刮风.add(树木摇动)
刮风.add(水面添加波纹效果)
add(刮风)
上面这个例子中显然我们希望这些效果是并行的
但有时我们也希望效果是顺序执行的
add(向前走2步)
add(左转)
add(向后退两步)
毫无疑问，如果转弯的时机稍有变动，这就是另一个结果了。

为了让事件在合适的时间运行，需要加入事件状态控制
事件有多个状态，如果不是RUNNING（运行）状态
事件就不更新，通过这种机制来控制事件。

事件的生命周期
NEW-->start()-->RUNNING-->block()-->BLOCKED-->start()-->RUNNING
-->stop()-->DEAD

在调用对应的函数时会自动修改状态，同时调用对应的
when...()函数
如start()调用whenStart()
该函数是留给用户可以修改的，后续可能还会加上一些事件监听
（特殊的，NEW-->RUNING中会调用firstStart()函数
可以在该函数中进行一些初始化工作等。
）

v1.0.1
设计事件中添加子事件是直接将传入的事件指针添加到队列中
当然这和完全封装的Scene系统是不同的。
Scene中希望外界不能持有内部的指针，
但是这里我们让外界持有了内部的指针
目前暂时不确认两种方法的优劣，所以只能两种都尝试一下。

当前的状态标志 eventType 改变是在调用对应的when之后的
如当前 RUNNING ,调用 block() 
whenBlock() 执行的时候 eventType 还是 RUNNING
以期可以给用户带来更多改变前的信息。


v1.0.2
改了之前的哪个 eventType 修改晚于 when 函数的策略。
因为继承自 Event 的 TimeLine 需要创建线程
而创建的线程是需要判断当前的状态的。

